<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ‰‹åŠ¿äº¤äº’ 3D ç²’å­ç³»ç»Ÿ</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #000; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; }
        #canvas-container { width: 100vw; height: 100vh; position: absolute; top: 0; left: 0; z-index: 1; }
        
        /* æ‘„åƒå¤´é¢„è§ˆ (éšè—æˆ–ç¼©å°æ˜¾ç¤ºç”¨äºè°ƒè¯•) */
        #video-input { position: absolute; bottom: 10px; left: 10px; width: 160px; height: 120px; transform: scaleX(-1); z-index: 2; border-radius: 8px; opacity: 0.5; pointer-events: none; }
        
        /* åŠ è½½æç¤º */
        #loader { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); color: white; font-size: 24px; z-index: 10; pointer-events: none; text-align: center; }
        
        /* å…¨å±æŒ‰é’® */
        #fullscreen-btn {
            position: absolute; bottom: 20px; right: 20px; z-index: 100;
            background: rgba(255, 255, 255, 0.1); border: 1px solid rgba(255, 255, 255, 0.3);
            color: white; padding: 10px 20px; border-radius: 20px; cursor: pointer;
            backdrop-filter: blur(5px); transition: 0.3s; text-transform: uppercase; font-size: 12px; letter-spacing: 1px;
        }
        #fullscreen-btn:hover { background: rgba(255, 255, 255, 0.3); }

        /* æ‰‹åŠ¿æç¤º */
        #instruction {
            position: absolute; top: 20px; left: 50%; transform: translateX(-50%);
            color: rgba(255,255,255,0.7); z-index: 5; font-size: 14px;
            background: rgba(0,0,0,0.5); padding: 8px 16px; border-radius: 20px;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="loader">æ­£åœ¨åŠ è½½ AI æ¨¡å‹ä¸ 3D å¼•æ“...<br><span style="font-size:14px; opacity:0.7">è¯·å…è®¸æ‘„åƒå¤´æƒé™</span></div>
    <div id="instruction">ğŸ‘‹ å¼ å¼€æ‰‹æŒæ‰©æ•£ç²’å­ï¼Œæ¡æ‹³é€šè¿‡ç²’å­èšåˆ</div>
    <video id="video-input" playsinline></video>
    <div id="canvas-container"></div>
    <button id="fullscreen-btn">å…¨å±æ¨¡å¼</button>

    <!-- å¼•å…¥ Three.js å’Œ ä¾èµ– -->
    <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
    <script type="importmap">
      {
        "imports": {
          "three": "https://unpkg.com/three@0.154.0/build/three.module.js",
          "three/addons/": "https://unpkg.com/three@0.154.0/examples/jsm/",
          "@mediapipe/hands": "https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js",
          "@mediapipe/camera_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js",
          "@mediapipe/drawing_utils": "https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js",
          "lil-gui": "https://unpkg.com/lil-gui@0.18.0/dist/lil-gui.esm.min.js"
        }
      }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import GUI from 'lil-gui';
        
        // ----------------------------------------------------------------
        // 1. å…¨å±€å˜é‡ä¸åˆå§‹åŒ–
        // ----------------------------------------------------------------
        const container = document.getElementById('canvas-container');
        const videoElement = document.getElementById('video-input');
        const loader = document.getElementById('loader');
        
        let scene, camera, renderer, controls;
        let particleSystem, geometry, material;
        let clock = new THREE.Clock();
        
        // çŠ¶æ€ç®¡ç†
        const params = {
            model: 'Heart',
            color: '#ff0055',
            particleCount: 15000,
            particleSize: 0.15,
            interactionStrength: 1.0, // æ‰‹åŠ¿å½±å“åŠ›åº¦
            autoRotate: true
        };

        // æ‰‹åŠ¿æ§åˆ¶å˜é‡
        let handScale = 1.0; // ç›®æ ‡ç¼©æ”¾å€¼
        let currentScale = 1.0; // å½“å‰å¹³æ»‘åçš„ç¼©æ”¾å€¼
        let handDetected = false;

        // ----------------------------------------------------------------
        // 2. Three.js åœºæ™¯è®¾ç½®
        // ----------------------------------------------------------------
        function initThree() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.02);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 30;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.autoRotate = params.autoRotate;
            controls.autoRotateSpeed = 1.0;

            // åˆ›å»ºåˆå§‹ç²’å­
            createParticles(params.model);

            // UI é¢æ¿
            setupGUI();

            // äº‹ä»¶ç›‘å¬
            window.addEventListener('resize', onWindowResize);
            document.getElementById('fullscreen-btn').addEventListener('click', toggleFullScreen);
            
            animate();
        }

        // ----------------------------------------------------------------
        // 3. ç²’å­å½¢çŠ¶ç”Ÿæˆé€»è¾‘ (æ•°å­¦å…¬å¼)
        // ----------------------------------------------------------------
        function getPointOnHeart(t) {
            // å¿ƒå½¢å‚æ•°æ–¹ç¨‹
            let x = 16 * Math.pow(Math.sin(t), 3);
            let y = 13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t);
            return new THREE.Vector3(x, y, 0).multiplyScalar(0.5);
        }

        function getPointOnSphere(u, v) {
            let r = 10;
            let x = r * Math.sin(u) * Math.cos(v);
            let y = r * Math.sin(u) * Math.sin(v);
            let z = r * Math.cos(u);
            return new THREE.Vector3(x, y, z);
        }

        function createParticles(shapeType) {
            if (particleSystem) scene.remove(particleSystem);

            const count = params.particleCount;
            const positions = new Float32Array(count * 3);
            const colors = new Float32Array(count * 3);
            const baseColor = new THREE.Color(params.color);

            for (let i = 0; i < count; i++) {
                let p = new THREE.Vector3();
                
                // æ ¹æ®æ¨¡å‹ç±»å‹ç”Ÿæˆåæ ‡
                if (shapeType === 'Heart') {
                    // 3D å¿ƒå½¢å˜ä½“
                    const t = Math.random() * Math.PI * 2;
                    const r = Math.random(); // å†…éƒ¨å¡«å……
                    let vec = getPointOnHeart(t);
                    // å¢åŠ Zè½´åšåº¦
                    vec.z = (Math.random() - 0.5) * 5; 
                    vec.multiplyScalar(r); // å¡«å……å†…éƒ¨
                    p.copy(vec);
                } 
                else if (shapeType === 'Saturn') {
                    // åœŸæ˜Ÿï¼šçƒä½“ + ç¯
                    if (i < count * 0.3) {
                        // æ˜Ÿçƒæœ¬ä½“
                        let u = Math.random() * Math.PI;
                        let v = Math.random() * Math.PI * 2;
                        let r = 6;
                        p.set(r * Math.sin(u) * Math.cos(v), r * Math.sin(u) * Math.sin(v), r * Math.cos(u));
                    } else {
                        // å…‰ç¯
                        let angle = Math.random() * Math.PI * 2;
                        let dist = 9 + Math.random() * 6;
                        p.set(Math.cos(angle) * dist, (Math.random()-0.5) * 0.5, Math.sin(angle) * dist);
                        // å€¾æ–œ
                        p.applyAxisAngle(new THREE.Vector3(1, 0, 1).normalize(), 0.4);
                    }
                }
                else if (shapeType === 'Flower') {
                    // ç«ç‘°æ›²çº¿/èŠ±æœµæ¨¡æ‹Ÿ
                    let theta = Math.random() * Math.PI * 2;
                    let phi = Math.random() * Math.PI;
                    let r = 10 * Math.sin(3 * theta) * Math.sin(phi); // 3ç“£
                    p.set(r * Math.sin(theta) * Math.cos(phi), r * Math.cos(theta), r * Math.sin(theta) * Math.sin(phi));
                }
                else if (shapeType === 'Buddha') {
                    // æŠ½è±¡ä½›åƒ (ä½¿ç”¨å åŠ çš„çƒä½“æ¨¡æ‹Ÿæ‰“åå§¿æ€ï¼Œå› ä¸ºæ— æ³•åŠ è½½å¤–éƒ¨æ¨¡å‹)
                    let section = Math.random();
                    if (section < 0.4) { // èº«ä½“/ç›˜è…¿
                         let u = Math.random() * Math.PI;
                         let v = Math.random() * Math.PI * 2;
                         let r = 6;
                         p.set(r * Math.sin(u) * Math.cos(v), r * Math.sin(u) * Math.sin(v) * 0.6 - 4, r * Math.cos(u));
                    } else if (section < 0.7) { // èƒ¸/å¤´
                         let u = Math.random() * Math.PI;
                         let v = Math.random() * Math.PI * 2;
                         let r = 3.5;
                         p.set(r * Math.sin(u) * Math.cos(v), r * Math.sin(u) * Math.sin(v) + 2, r * Math.cos(u));
                    } else { // å…‰ç¯
                        let angle = Math.random() * Math.PI * 2;
                        let dist = 5 + Math.random() * 2;
                        p.set(Math.cos(angle) * dist, Math.sin(angle) * dist + 5, 0);
                    }
                }
                else if (shapeType === 'Fireworks') {
                    // çƒŸèŠ±ï¼šçƒå½¢éšæœºåˆ†å¸ƒï¼ŒåŠ¨ç”»ä¸­ä¼šç”¨åˆ°
                    let u = Math.random() * Math.PI * 2;
                    let v = Math.random() * Math.PI * 2;
                    let r = Math.random() * 10;
                    p.set(r * Math.sin(u) * Math.cos(v), r * Math.sin(u) * Math.sin(v), r * Math.cos(u));
                }

                // èµ‹å€¼ä½ç½®
                positions[i * 3] = p.x;
                positions[i * 3 + 1] = p.y;
                positions[i * 3 + 2] = p.z;

                // é¢œè‰²éšæœºå¾®è°ƒ
                colors[i * 3] = baseColor.r + (Math.random() - 0.5) * 0.2;
                colors[i * 3 + 1] = baseColor.g + (Math.random() - 0.5) * 0.2;
                colors[i * 3 + 2] = baseColor.b + (Math.random() - 0.5) * 0.2;
            }

            geometry = new THREE.BufferGeometry();
            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
            
            // ä¿å­˜åŸå§‹ä½ç½®ç”¨äºæ¢å¤
            geometry.userData.originalPositions = positions.slice();

            // ç®€å•çš„å‘å…‰çº¹ç†
            const sprite = new THREE.TextureLoader().load('https://threejs.org/examples/textures/sprites/disc.png');

            material = new THREE.PointsMaterial({
                size: params.particleSize,
                vertexColors: true,
                map: sprite,
                blending: THREE.AdditiveBlending,
                depthTest: false,
                transparent: true,
                opacity: 0.8
            });

            particleSystem = new THREE.Points(geometry, material);
            scene.add(particleSystem);
        }

 // ----------------------------------------------------------------
// 4. MediaPipe Hands æ‰‹åŠ¿è¯†åˆ«
// ----------------------------------------------------------------
async function setupMediaPipe() {
    try {
        // æ£€æŸ¥æµè§ˆå™¨æ˜¯å¦æ”¯æŒ
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            throw new Error('æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´åŠŸèƒ½');
        }

        // å…ˆè¯·æ±‚æ‘„åƒå¤´æƒé™
        const stream = await navigator.mediaDevices.getUserMedia({
            video: {
                width: 640,
                height: 480,
                facingMode: 'user'
            }
        });

        videoElement.srcObject = stream;
        await videoElement.play();

        // åŠ¨æ€å¯¼å…¥ MediaPipe
        const script1 = document.createElement('script');
        script1.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';
        script1.type = 'text/javascript';

        const script2 = document.createElement('script');
        script2.src = 'https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js';
        script2.type = 'text/javascript';

        await new Promise((resolve, reject) => {
            let loaded = 0;
            const checkLoaded = () => {
                loaded++;
                if (loaded === 2) {
                    setTimeout(resolve, 100);
                }
            };

            script1.onload = checkLoaded;
            script2.onload = checkLoaded;
            script1.onerror = reject;
            script2.onerror = reject;

            document.head.appendChild(script1);
            document.head.appendChild(script2);
        });

        // ç°åœ¨åº”è¯¥å¯ä»¥åœ¨ window ä¸Šè®¿é—®äº†
        const { Hands } = window;
        const { Camera } = window;

        if (!Hands || !Camera) {
            throw new Error('MediaPipe åº“åŠ è½½å¤±è´¥');
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 2,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onHandsResults);

        const cameraInput = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({image: videoElement});
            },
            width: 640,
            height: 480
        });

        await cameraInput.start();
        loader.style.display = 'none'; // éšè—åŠ è½½æ–‡å­—

    } catch (e) {
        console.error("MediaPipe åˆå§‹åŒ–å¤±è´¥:", e);
        loader.innerHTML = "æ‘„åƒå¤´å¯åŠ¨å¤±è´¥: " + e.message +
                          "<br>è¯·ç¡®ä¿ï¼š<br>1. ä½¿ç”¨ HTTPS æˆ–æœ¬åœ°æœåŠ¡å™¨<br>2. å…è®¸æ‘„åƒå¤´æƒé™<br>3. ä½¿ç”¨ç°ä»£æµè§ˆå™¨";
    }
}

        function onHandsResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                
                // è®¡ç®—æ‰‹åŠ¿å¼ å¼€ç¨‹åº¦
                // æˆ‘ä»¬ä½¿ç”¨æ‹‡æŒ‡æŒ‡å°–(4)ä¸å°æŒ‡æŒ‡å°–(20)çš„è·ç¦»ï¼Œæˆ–è€…æ˜¯æ‰€æœ‰æŒ‡å°–åˆ°æ‰‹è…•(0)çš„å¹³å‡è·ç¦»
                let totalOpenness = 0;

                results.multiHandLandmarks.forEach(landmarks => {
                    // æ‰‹è…•ç‚¹
                    const wrist = landmarks[0];
                    
                    // æŒ‡å°–ç‚¹: 4, 8, 12, 16, 20
                    const tips = [4, 8, 12, 16, 20];
                    let avgDist = 0;

                    tips.forEach(tipIdx => {
                        const tip = landmarks[tipIdx];
                        // è®¡ç®—æ¬§å‡ é‡Œå¾—è·ç¦»
                        const d = Math.sqrt(
                            Math.pow(tip.x - wrist.x, 2) + 
                            Math.pow(tip.y - wrist.y, 2)
                        );
                        avgDist += d;
                    });
                    
                    // å½’ä¸€åŒ–å¤§è‡´èŒƒå›´ (æ‰‹æ¡ç´§çº¦ä¸º0.15ï¼Œå¼ å¼€çº¦ä¸º0.4-0.5)
                    avgDist /= 5; 
                    totalOpenness += avgDist;
                });

                // å¦‚æœæœ‰ä¸¤åªæ‰‹ï¼Œå–å¹³å‡
                let rawValue = totalOpenness / results.multiHandLandmarks.length;
                
                // æ˜ å°„ rawValue åˆ° ç¼©æ”¾ç³»æ•°
                // æ¡æ‹³ (rawValue ~0.1) -> scale 0.2 (æ”¶ç¼©)
                // å¼ å¼€ (rawValue ~0.4) -> scale 2.0 (æ‰©æ•£)
                
                // ç®€å•çš„çº¿æ€§æ˜ å°„
                let mappedScale = (rawValue - 0.15) * 6; 
                // é™åˆ¶èŒƒå›´
                if (mappedScale < 0.2) mappedScale = 0.2;
                if (mappedScale > 2.5) mappedScale = 2.5;

                handScale = mappedScale;

            } else {
                handDetected = false;
                handScale = 1.0; // æ— æ‰‹åŠ¿æ—¶æ¢å¤é»˜è®¤
            }
        }

        // ----------------------------------------------------------------
        // 5. åŠ¨ç”»ä¸äº¤äº’
        // ----------------------------------------------------------------
        function animate() {
            requestAnimationFrame(animate);

            const time = clock.getElapsedTime();
            const delta = clock.getDelta();

            // 1. å¹³æ»‘å¤„ç†æ‰‹åŠ¿ç¼©æ”¾
            // ä½¿ç”¨ lerp æ’å€¼ï¼Œä½¿å˜åŒ–ä¸çªå…€
            currentScale = THREE.MathUtils.lerp(currentScale, handScale, 0.1);

            // 2. æ›´æ–°ç²’å­ä½ç½®
            if (particleSystem) {
                const positions = particleSystem.geometry.attributes.position.array;
                const originalPositions = particleSystem.geometry.userData.originalPositions;

                // å‘¼å¸æ•ˆæœåŸºç¡€é¢‘ç‡
                const breathe = Math.sin(time * 2) * 0.1 + 1;
                
                // æœ€ç»ˆç¼©æ”¾ = æ‰‹åŠ¿æ§åˆ¶ * å‘¼å¸æ•ˆæœ
                const finalScale = currentScale * breathe;

                for (let i = 0; i < params.particleCount; i++) {
                    const idx = i * 3;
                    
                    // åŸºç¡€ä½ç½®
                    let ox = originalPositions[idx];
                    let oy = originalPositions[idx + 1];
                    let oz = originalPositions[idx + 2];

                    // åº”ç”¨ç¼©æ”¾
                    let tx = ox * finalScale;
                    let ty = oy * finalScale;
                    let tz = oz * finalScale;

                    // æ·»åŠ ä¸€äº›åŸºäºæ—¶é—´çš„å™ªå£°/æŠ–åŠ¨ï¼Œè®©ç²’å­çœ‹èµ·æ¥æ˜¯æ´»çš„
                    if (params.model === 'Fireworks' && handScale > 1.5) {
                        // çƒŸèŠ±æ¨¡å¼ä¸‹ï¼Œæ‰‹å¼ å¼€æ—¶å¢åŠ éšæœºæ‰©æ•£
                        tx += (Math.random() - 0.5) * 0.5;
                        ty += (Math.random() - 0.5) * 0.5;
                        tz += (Math.random() - 0.5) * 0.5;
                    } else {
                        // æ™®é€šæ¨¡å¼ä¸‹çš„å¾®åŠ¨
                        tx += Math.sin(time + ox) * 0.05;
                        ty += Math.cos(time + oy) * 0.05;
                    }

                    positions[idx] = tx;
                    positions[idx + 1] = ty;
                    positions[idx + 2] = tz;
                }
                
                particleSystem.geometry.attributes.position.needsUpdate = true;
                particleSystem.rotation.y += 0.002; // æ•´ä½“ç¼“æ…¢è‡ªè½¬
            }

            controls.autoRotate = params.autoRotate && !handDetected; // æ‰‹åŠ¿æ§åˆ¶æ—¶åœæ­¢è‡ªåŠ¨æ—‹è½¬
            controls.update();
            renderer.render(scene, camera);
        }

        // ----------------------------------------------------------------
        // 6. UI ä¸ å·¥å…·å‡½æ•°
        // ----------------------------------------------------------------
        function setupGUI() {
            const gui = new GUI({ title: 'æ§åˆ¶é¢æ¿' });
            
            gui.add(params, 'model', ['Heart', 'Saturn', 'Flower', 'Buddha', 'Fireworks'])
                .name('æ¨¡å‹é€‰æ‹©')
                .onChange(val => createParticles(val));
            
            gui.addColor(params, 'color')
                .name('ç²’å­é¢œè‰²')
                .onChange(val => createParticles(params.model)); // é‡å»ºä»¥åº”ç”¨é¢œè‰²
            
            gui.add(params, 'particleSize', 0.01, 0.5)
                .name('ç²’å­å¤§å°')
                .onChange(val => { material.size = val; });

            gui.add(params, 'autoRotate').name('è‡ªåŠ¨æ—‹è½¬');
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function toggleFullScreen() {
            if (!document.fullscreenElement) {
                document.documentElement.requestFullscreen();
                document.getElementById('fullscreen-btn').innerText = "é€€å‡ºå…¨å±";
            } else {
                if (document.exitFullscreen) {
                    document.exitFullscreen();
                    document.getElementById('fullscreen-btn').innerText = "å…¨å±æ¨¡å¼";
                }
            }
        }

        // å¯åŠ¨ç¨‹åº
        initThree();
        // å»¶è¿Ÿä¸€ç‚¹å¯åŠ¨ MediaPipe ä»¥ç¡®ä¿ DOM åŠ è½½
        setTimeout(setupMediaPipe, 1000);

    </script>
</body>
</html>
